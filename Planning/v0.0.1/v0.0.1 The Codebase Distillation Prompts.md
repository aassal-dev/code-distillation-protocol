# The Codebase Distillation Prompts

These prompts are designed to be used in Cursor AI (Composer Mode), Claude Code, or any large-context CLI tool.

## Phase 1: The Reconnaissance (High-Level Mapping)

_Use this prompt first to get the lay of the land._

> **Prompt:**
> 
> "I want you to act as a Senior Software Architect specializing in Reverse Engineering. We are looking at the codebase of [Repo Name].
> 
> **Goal:** Create a high-level map of the system to identify the 'Nerve Centers'â€”the files where the most critical, complex, or valuable logic resides.
> 
> **Tasks:**
> 
> 1. Analyze the project structure and dependency files (package.json, go.mod, cargo.toml, etc.).
>     
> 2. Identify the Tech Stack and Key Libraries.
>     
> 3. List the Top 5-10 files that likely contain the 'Secret Sauce' (core logic, custom algorithms, complex state management). Ignore boilerplate (UI components, simple CRUD).
>     
> 4. Explain _why_ you selected these files.
>     
> 
> **Output:** A concise Markdown summary titled 'Architecture Recon'."

## Phase 2: The "Gem Hunter" (Deep Extraction)

_Use this prompt after you have identified the critical files. Point the AI to those specific folders/files._

> **Prompt:**
> 
> "Focus your attention on [List of Critical Files/Directories identified in Phase 1].
> 
> **Goal:** Extract 'Cunning Tricks', Design Patterns, and Masterful Implementations. I am looking for code that makes you say 'Wow, that's smart.'
> 
> **Analysis Criteria:**
> 
> 1. **Pattern Recognition:** What recurring architectural patterns are used? (e.g., Adapter pattern, Observer, specific factory methods).
>     
> 2. **Performance Hacks:** Are there specific optimizations (memoization, buffer pooling, lazy loading)?
>     
> 3. **Error Handling:** How do they handle failure elegantly?
>     
> 4. **DX (Developer Experience):** How do they make their own lives easier (custom hooks, utility types, helper functions)?
>     
> 
> **Output format:**
> 
> Please generate a report called `INSIGHTS.md`. For each finding, provide:
> 
> - **The Concept:** Name of the trick/pattern.
>     
> - **The Implementation:** A simplified code snippet showing how they did it.
>     
> - **The 'Why':** Why is this better than the standard approach?
>     
> - **Replicability:** How can I use this in a _different_ project?"
>     

## Phase 3: The Codification (Creating the AI Rules)

_This is the most critical step. It turns the analysis into instructions for your future AI agent._

> **Prompt:**
> 
> "Based on the analysis of [Repo Name], I want you to distill the engineering wisdom into a set of System Instructions that I can use to train _you_ (the AI) to write code like this in the future.
> 
> **Goal:** Create a file named `.cursorrules` (or `coding_standards.md`) that encapsulates the 'Soul' of this codebase.
> 
> **Content Requirements:**
> 
> 1. **Preferred Syntax:** (e.g., 'Always use functional components', 'Prefer composition over inheritance').
>     
> 2. **Architectural Enforcements:** (e.g., 'All state must be lifted to X', 'Never access the DB directly from Y').
>     
> 3. **Snippet Bank:** Extract the 3 most useful utility functions or patterns into a library of reusable snippets.
>     
> 
> **Tone:** Authoritative and instructional.
> 
> **Format:**
> 
> Use the 'Rule/Reason/Example' format for every instruction."