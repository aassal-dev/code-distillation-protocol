# Knowledge Extraction Protocol — v0.2.06 Plan

**Purpose:** Capture insights from v0.2.05 runs (OpenClaw 72-LT extraction, pattern library review) to improve the next version of the knowledge extraction system.

**Placement:** This document lives in the protocol repo under `Planning/v0.2.06 Plan`. A copy is also under `openclaw/_distillation/Planning/v0.2.06-Plan.md` for use alongside extraction artifacts.

---

## 1. Summary of v0.2.05 learnings

- **72 learning targets** were turned into 72 findings, then merged by the Librarian into **14 new patterns** plus **58 merges** into existing patterns (see _Why 72 targets → 14 new patterns_ in the OpenClaw `_distillation/WHY_72_TARGETS_14_NEW_PATTERNS.md`).
- **Pattern stand-alone quality** is mixed: many BMAD and some OpenClaw patterns have strong Code sections; others are thin (comment-only or single snippet) and require the source repo to implement from the pattern.
- **Librarian** merge rule (“one canonical pattern per concept”) is correct but was applied without an explicit **concept → pattern** mapping table; documenting merge decisions would help audit and reuse.

---

## 2. Pattern quality & stand-alone-ness (for v0.2.06)

### 2.1 Observation

A pattern is **stand-alone** when someone can implement the idea in a new codebase **without** opening the source repo. That depends heavily on the **Code** section.

- **Strong:** 5–15+ lines of real code (or full schema example) showing the core logic, data flow, or API.
- **Thin:** Code section is only commented function names, a single one-liner, or prose-only “see source_path”.

### 2.2 Evidence from review

- **Stand-alone enough (no source repo needed):**  
  e.g. `ordered-template-pipeline`, `replacements-reverse-order-preserve-indices`, `placeholder-regex-escape-for-replace`, `deep-merge-array-append-non-empty-override`, `file-based-command-registry`, `manifest-as-source-of-truth-fallback`, `composition-root-constructor-orchestrator`, `agent-yaml-menu-triggers-and-exec`, `structured-instructions-step-check-ask`, `detection-paths-instead-of-config-dir`, `tool-result-truncation-with-suffix`, `code-aware-reasoning-tag-stripping`.
- **Thin (concept clear, implementation incomplete without repo):**  
  e.g. `find-config-resolve-path-discover` (only `resolvePath` in code; `findBmadConfig` and `discoverAgents` in prose only); `context-compaction-head-tail-preservation` (comment-only: function names, no slice logic).

### 2.3 Suggested improvement for v0.2.06

- **Atomizer (step-02) mandate:** For every finding, the **Code** section must contain at least one of:
  - A **minimal working slice** (typically 5–15 lines) that shows the core logic, **or**
  - A **complete small example** (e.g. one function, one schema block) that is copy-paste adaptable.
- **Do not** allow Code to be only commented function names or “see source_path” unless the pattern is explicitly a “pointer” type (and document that in the template).
- **Librarian (step-03) optional pass:** When promoting a finding to a pattern, if the Code section is thin, the Librarian may **enrich** it by extracting one minimal slice from the source at `source_path` (same repo) and appending it to the Code block, with a one-line comment that it was extracted for stand-alone use.

### 2.4 Template / schema addition (optional)

- Add an optional frontmatter field: **`standalone: true | false`** (or **`code_completeness: minimal | full | pointer`**).
- Atomizer sets it; Librarian preserves or upgrades it.
- Enables filtering “patterns I can implement without the repo” vs “patterns that require source for details.”

---

## 3. Librarian merge strategy (for v0.2.06)

### 3.1 Current behavior

- Merge duplicate findings into one canonical pattern per concept.
- No explicit output that records “finding F merged into pattern P” or “concept C → pattern P.”

### 3.2 Suggested improvement

- **Merge map (optional artifact):** Librarian produces `library/merge-map.json` (or similar) listing, for each finding id (or target_id), which pattern id it was merged into (or “new” if it became a new pattern). Example:
  ```json
  {
    "finding_lt-1-hitl_hitl-async-suspension": "pattern_hitl-async-suspension-via-gateway",
    "finding_lt-31-prompt-canary_*": "new:pattern_prompt-injection-canary-regex"
  }
  ```
- **Rationale:** Audit trail for “why did 72 findings produce 14 new patterns?”; supports traceability from learning target → finding → pattern.

### 3.3 Concept naming

- Consider adding a short **concept_id** (e.g. `hitl-async-suspension`) to the extraction plan and findings so merge decisions are keyed by concept_id, not only by free-text “same concept.”

---

## 4. Atomizer (step-02) improvements

### 4.1 Code section requirements (see §2)

- Require a minimal working slice or complete small example in Code; disallow comment-only Code unless explicitly marked as pointer-type.

### 4.2 Fractal levels and line-level

- Line-level findings should still include **how** and **why** (e.g. “this regex order matters because …”). Code for line-level can be 1–5 lines but must be real code, not just references.

### 4.3 Batch size and context

- For large plans (e.g. 72 targets), batching by `abstraction_level` or by directory is already recommended. v0.2.06 could add a **recommended batch ordering** (e.g. process Line-Level after Module so Code snippets can reference module structure).

---

## 5. Director & learning objectives (for v0.2.06)

### 5.1 Learning target count — proportional to code size

- The number of Learning Targets should be **proportional to the size of the code** (no fixed minimum or maximum).
- Surveyor and Atomizer process all listed targets.

### 5.2 Checklist wording (v0.2.06)

- Require: “learning_objectives.md is present; number of Learning Targets is proportional to the size of the code.”

---

## 6. Checklist & validation (for v0.2.06)

### 6.1 New checklist item (optional)

- **Pattern Code completeness:** “No pattern has a Code section that consists only of comments or file references; each has at least a minimal working slice or a complete small example (or is explicitly marked as pointer-only).”

### 6.2 State and merge transparency

- If merge-map is adopted: “When Librarian produced more than one pattern from N findings, a merge map or equivalent is present (e.g. merge-map.json or merge summary in README).”

---

## 7. Document and artifact consistency

### 7.1 README and quick lookup

- Library README quick lookup is valuable. v0.2.06 could recommend **one line per pattern** in quick lookup (by topic/tag) so that every pattern appears in at least one bucket (no “orphan” patterns).

### 7.2 Source_repo and source_path

- All patterns already carry `source_repo` and `source_path`. Consider recommending that when a pattern is **merged** from multiple findings, the canonical pattern keeps **one** primary source_repo/source_path (e.g. the most canonical finding) and optionally lists others in a “Also derived from” line in the pattern or in the merge map.

### 7.3 Tags

- Tag taxonomy is in README (semantic tag categories). v0.2.06 could add a short **tagging guideline** for Atomizer/Librarian: prefer existing tags from the table; add new tags only when no existing tag fits (and then consider adding the new tag to the README table in the same run).

---

## 8. Suggested changes summary (v0.2.06)

| Area              | Change                                                                                                             |
| ----------------- | ------------------------------------------------------------------------------------------------------------------ |
| **Atomizer**      | Require Code = minimal working slice or complete small example; disallow comment-only Code unless pointer-type.    |
| **Librarian**     | Optional: produce merge-map (finding → pattern); optional: enrich thin Code from source when promoting to pattern. |
| **Template**      | Optional: `standalone` or `code_completeness` in frontmatter.                                                      |
| **Checklist**     | Number of LTs proportional to code size. Add optional Pattern Code completeness and merge-map checks.              |
| **Plan/Surveyor** | Optional: concept_id in plan entries and findings for merge keying.                                                |
| **README**        | Recommend every pattern in at least one quick-lookup bucket; optional tagging guideline.                           |

---

## 9. References (from v0.2.05)

- **Why 72 → 14 patterns:** OpenClaw `_distillation/WHY_72_TARGETS_14_NEW_PATTERNS.md`
- **Stand-alone pattern review:** Conversation notes on BMAD vs OpenClaw pattern Code sections; strong vs thin patterns.
- **Workflow:** V0.2.05 workflow.md, step-00 (Director), step-01 (Surveyor), step-02 (Atomizer), step-03 (Librarian), checklist.md.
