# Standardized Output Templates (v0.2.05)

**Philosophy:** One concept = one file. **Single source of truth:** one schema for both finding (Phase 2) and pattern (Phase 3). Same frontmatter and section order everywhere.

## Template: Finding / Pattern (`finding_*.md` → `pattern_*.md`)

Use this **one** template for Atomizer output (findings) and Librarian output (library patterns). Order: frontmatter → Problem → Solution → Code → AI Rule (ordered-template-pipeline). **Optional:** when Blueprint extraction was used, add a **Theory vs. Practice** section (see below).

### YAML frontmatter (required)

```yaml
---
id: unique-kebab-id
name: Human-readable name of the pattern or trick
type: pattern | trick
abstraction: system | module | class | line-level
quality: cunning | novel | masterful
source_repo: Repo name (e.g. BMAD-METHOD)
source_path: path/within/repo/to/source
tags: [tag1, tag2, tag3]
---
```

- **id:** Unique kebab-case identifier (e.g. `compound-trigger-single-regex-two-captures`).
- **name:** Short title for humans.
- **type:** `pattern` or `trick` (optimization/anti-pattern fold into these).
- **abstraction:** System | Module | Class | Line-Level (align with extraction_plan abstraction_level).
- **quality:** Must be one of cunning | novel | masterful. Common-knowledge-only findings are discarded in Librarian.
- **source_repo:** Name of the distilled repository.
- **source_path:** File or path where this insight comes from (required).
- **tags:** Semantic tags for retrieval (e.g. regex, template-engine, cli, security).

### Sections (fixed order)

1. **# Title** — Same as `name` or a brief variant.
2. **## Problem** — Why did they need this? What does the standard approach miss?
3. **## Solution** — The trick or pattern in words (the "why" and the "what").
4. **## Code** — One or more code blocks showing the implementation. Prefer minimal, representative snippets.
5. **## AI Rule** — Instructions for an AI (e.g. Cursor rule): **Trigger:** when to apply; **Guidelines:** what to do / avoid; **Reference:** key snippet or constraint.
6. **## Theory vs. Practice** _(optional, Blueprint runs only)_ — How the textbook/theory concept was adapted, optimized, or worked around in this codebase. Include when the run used a Blueprint/theory file and this finding maps to a theory concept.

### Filenames

- **Finding (Phase 2):** `finding_{target_id}_{short_name}.md` (e.g. `finding_mod-config-driven-ide_ordered-template-pipeline.md`).
- **Pattern (Phase 3):** `pattern_{kebab-name}.md` (e.g. `pattern_ordered-template-pipeline.md`). Use `id` as the kebab-name when they match.

### Example (pattern with optional Theory vs. Practice)

````markdown
---
id: compound-trigger-single-regex-two-captures
name: One Regex for Structured Compound Format with Two Captures
type: trick
abstraction: line-level
quality: cunning
source_repo: BMAD-METHOD
source_path: tools/schema/agent.js
tags: [schema, regex, trigger, compound, shortcut, kebab-case]
---

# Single Regex for Compound Trigger Format with Captures

## Problem

Compound menu triggers have a fixed format: "<SHORTCUT> or fuzzy match on <kebab-case>". Validating and parsing need the shortcut and the kebab part separately. Splitting on a string is brittle.

## Solution

One regex with two capture groups: group 1 = shortcut, group 2 = kebab trigger. Use exec(); return { valid, shortcut, kebabTrigger } or { valid: false, error }.

## Code

```javascript
const COMPOUND_TRIGGER_PATTERN =
  /^([A-Z]{1,3}) or fuzzy match on ([a-z0-9]+(?:-[a-z0-9]+)*)$/;
// ...
```

## AI Rule

**Trigger:** When parsing a fixed-format string with two logical parts.

1. **Use** a single anchored regex with two capture groups.
2. **Return** { valid, error } or { valid, ...parts }.
3. **Reuse** the same subpattern for the second part as elsewhere.

## Theory vs. Practice _(optional)_

_(When Blueprint was used: describe how the theory/chapter concept was implemented or adapted here.)_
````

---

**Reference:** Align with distillation pattern format in BMAD-METHOD _distillation/patterns (pattern_\*.md and README.md). Do not introduce a different schema for findings vs library; this template is the single source of truth.
