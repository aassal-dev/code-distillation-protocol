# Standardized Output Templates

**Version:** 0.1.0

**Philosophy:** One Concept = One File.

## Template: The Pattern Atom (`pattern_[name].md`)

_This file contains BOTH the human context and the AI rule. This is the single source of truth for one specific piece of knowledge._

````
---
id: [unique-id-e.g-pattern-react-event-buffer]
type: [pattern | trick | optimization | anti-pattern]
abstraction: [system | module | class | line-level]
source_repo: [Repo Name]
tags: [react, performance, websockets, memory-safe]
---

# ðŸ§  Human Insight: [Name of the Pattern]

### The Problem
*Why did they need this?*
> The standard `JSON.parse` was blocking the main thread for large payloads.

### The Solution (The "Trick")
They used a **Line-Level Optimization**: A custom streaming parser that yields control back to the event loop every 50ms.

### Code Analysis (The "Metal")
*Specific focus on the implementation details.*
```typescript
// Their clever implementation
function* streamParse(jsonString) {
   // ... bitwise check for bracket closure
   if ((byte & 0x80) !== 0) { ... } // Fast bitwise check
}
````

# ðŸ¤– AI Instruction (Context Rule)

_Copy the block below into `.cursorrules` or save as `.mdc` context._

#### Rule: [Name of Pattern]

**Trigger:** When parsing large JSON payloads (>1MB) or handling heavy computation.

**Guidelines:**

1. **Avoid** standard `JSON.parse` for blocking operations.
    
2. **Must** implement a generator-based parsing approach.
    
3. **Line-Level Optimization:** Use bitwise operators for character checking where possible for speed.
    

**Reference Snippet:**

```
// Insert optimized snippet here
```

```

## Template: The "Lesson Learned" Card (`lesson_[name].md`)
*(Same as above, but ensure YAML tags include `abstraction` field)*
```